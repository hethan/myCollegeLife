<font size = 3> 

[toc]
NumPy是目前Python数值计算中最为重要的基础包。大多数计算包都提供了基于NumPy的科学函数功能，将NumPy的数组作为数据交换的通用语。  
以下内容会出现在NumPy中：
- ndarry,一种高效多维数组，提供了基于数组的便捷算术操作以及灵活的广播功能。
- 对所有数据进行快速的矩阵计算，而无须编写循环程序。
- 对硬盘中数组数据进行读写的工具，并对内存映射文件进行操作。
- 线性代数、随机数生成以及傅里叶变换功能
- 用于连接NumPy到C、C++和FORTRAN语言类库的C语言API

**由于NumPy提供了一个非常易用的C语言API，将数据传递给底层语言编写的外部类库，再由外部类库将计算结果按照NumPy数组的方式返回，变得简单。这个特性使得Python可以对存量C/C++/FORTRAN代码库进行封装，并为这些代码提供动态、易用的接口。**  

对于大多数的数据分析应用，主要关注的内容为：
- 在数据处理、清洗、构造子集、过滤、交换以及其他计算中进行快速的向量化计算。
- 常见的数组算法。
- 高效的描述性统计和聚合/概述数据。
- 数据排列和相关数据操作。
- 使用数据表达式来表明条件逻辑。
- 分组数据的操作。

NumPy的设计对于含有大量数组的数据非常有效。此外，
- NumPy在内部将数据存储在连续的内存块上，这与其他的Python内建数据结构是不同的。NumPy的算法库是用C语言写的，所以在操作数据内存时，并不需要任何类型检查或者其他管理操作。NumPy数组使用的内存量也小于其他Python内建序列。
- NumPy可以针对全量数组进行复杂计算而不需要写Python循环。


# 4.1 NumPy ndarray：多维数组对象  
NumPy的核心特征之一就是N-维数组对象——ndarray。  
ndarray是Python中一个快速、灵活的大型数据集容器。数组允许使用类似于标量的操作语法在整块数据上进行数学计算。  

**标准NumPy导入方式：import numpy as np**  

ndarray是一个通用的多维同类数据容器，也就是说，它包含的每一个元素均为相同类型。**每一个数组都有一个shape属性，用来表征数组每一维度的数量；每一个数组都有一个dtype属性，用来描述数组的数据类型**
```python
>>> data.dtype
 dtype('float64')
```
## 4.1.1 生成ndarry
生成数据最简单的方式就是使用array函数。array函数接收任意的序列型对象，生成一个新的包含传递数据的NumPy数组。  
```python
>>> data = [6, 6]
>>> arr = np.array(data)
```
嵌套序列将会自动转换成多维数组。  

除了np.array，还有许多其他函数可以创建新数组。给定长度及形状后，zeros可以一次性创造全0数组，ones可以创造全1数组。empty则可以创建一个没有初始化数值的数组。  
```python
>>> np.zeros((3,6))
 array([[0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0.]])
```

arange是Python内建函数range的数组版：
```python
>>> np.arange(10)
 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

**数组生成函数**  
| 函数名 | 描述 |
| :-----: | :----: |
| array | 将输入数据转换为ndarray,如不显示指明数据，将自动推断；默认赋值所有的输入数据 |
| asarray | 将输入转换为ndarry,但如果输入已经是ndarray则不再复制 |
| arange | 是Python内建函数range的数组版,返回一个数组 |
| ones | 根据给定形状和数据类型生成全1数组 |
| ones_like | 根据所给的数组生成一个形状一样的全1数组 |
| zeros | ... |
| zeros_like | ... |
| empty | ... |
| empty_like | ... |
| full | 根据给定的形状和数据类型生成指定数值的数组 |
| full_like | 根据所给的数组生成一个形状一样但内容是指定数值的数组 |
| eye,identity | 生成一个N*N特征矩阵（对角线都是1，其余位置都是0） |
```python
>>> np.full((2,3), 10)
 array([[10, 10, 10],
       [10, 10, 10]])
>>> np.eye(2)
 array([[1,0],[0,1]])
```
## 4.1.2 ndarray的数据类型
数据类型（dtype）是一个特殊的对象，它包含了ndarray需要为某一种类型数据所申明的内存块信息（也称为元数据，即表示数据的数据）

dtype是NumPy能够与其他系统数据灵活交互的原因。通常，其他系统提供一个硬盘或内存与数据的对应关系，使得利用C或Fortran等底层语言读写数据变得十分方便。

**astype方法显示地转换数组的数据类型**  
```python
>>> arr = np.array([1,3,4])
>>> arr.dtype
 dtype('int64')
>>> arr = arr.astype(np.float64)
>>> arr.dtype
 dtype('float64')
```

**在NumPy中，当使用numpy.string_类型作字符串数据要小心，因为NumPy会修正它的大小或删除且不发出警告**  

**如果因为某些原因导致转换类型失败，将会抛出ValueError。**
## 4.1.3 NumPy数组算术
数组之所以重要是因为它允许进行批量操作而无须任何for循环。NumPy用户称这中特性为向量化。  
任何等尺寸数组之间的算术操作都应用了逐元素操作的方式。

带有标量计算的算术操作，会把计算参数传递给数组的每一个元素   
```python
>>> arr = np.array([1,2,3])
>>> arr = 2*arr
>>> arr
 array([2, 4, 6])
```

同尺寸数组之间的比较，会产生一个布尔值数组

**不同尺寸的数组间的操作，将会用到广播特性**  
```python
>>> arr1 = np.array([1,2,3])
>>> arr2 = np.ones((3,2))
>>> arr1*arr2
 array([[1,2,3],[1,2,3]])
>>>
>>>
>>> arr3 = np.full((2, 1), 10)
>>> arr1*arr3
 error
```
## 4.1.4 基础索引与切片
NumPy数组索引可以选中数据的子集或某个单元。

**区别于Pytho的内建列表，数组的切片是原数组的视图。这意味着数据并不是被复制了，任何对于视图的修改都会反映到原数组上。**
```python
>>> arr = np.arrange(10)
>>> arr
 array([0,1,2,3,4,5,6,7,8,9])
>>> arr_s = arr[2:4]
>>> arr_s[:] = 6
>>> arr
 array([0,1,6,6,4,5,6,7,8,9])
```

如果想要数组切片的拷贝而不是一份视图，则必须是显示复制数组，copy
```Python
>>> arr[3:8].copy()
 array([3,4,5,6,7])
```

对于一个二维数组，想要获得其单个值，可以用以下两种方法：
```Python
>>> arr2d = array([[2,4,6],[1,2,3]])
>>> arr2d[1,2]
 3
>>>
>>> arr2d[1][2]
 3
```

**在多维数组中可以省略后续索引值，返回对象将是降低一个纬度的数组**  
标量和数组都可以传递给降纬的数组。
```Python
>>> arr3d = np.array([[[1,2,3],
                       [4,5,6]],
                      [[7,8,9],
                       [10,11,12]]])
>>> arr3d[0] = 42
>>> arr3d
 array([[[42,42,42],
        [42,42,42]],
        [[7,8,9],
        [10,11,12]]])
```

### 4.1.4.1 数组的切片索引
多组切片：
```python
>>> arr2d = np.array([[2,3,4],[5,6,7],[8,1,2]])
>>> arr2d[ : 2, : 2]
array([[2,3],[5,6]])
```
如果将索引和切片混合，就可以得到低纬度的切片
## 4.1.5 布尔索引
```python
>>> arr2d = np.array([[2,3,4],[3,4,5],[6,7,8],[1,2,3]])
>>> vis = np.array([True, False, True, False])
>>> arr2d[vis]
 array([[2,3,4],[6,7,8]])
```
**布尔值数组的长度必须和数组轴索引长度一致。还可以使用切片或整数值（或整数值的序列）对布尔值数组进行混合和匹配**  

**使用布尔值索引选择数据时，总是生成数据的拷贝，即使返回的数组并没有任何变化。**  
```pyhon
>>> arr_s = arr2d[vis]
>>> arr_s
>>> arr_s[0] = 1
>>> arr_s
 array([[1,1,1],[6,7,8]])
>>> arr2d
 array([[2,3,4],[3,4,5],[6,7,8],[1,2,3]])
```

将数组中所有负值设置为0：
```python
>>> arr = np.random.randn(6,3)
>>> arr
array([[ 0.27394406, -0.00375143, -1.27202986],
       [ 0.66583687, -1.60790148, -1.08791542],
       [-0.70913568,  1.39024467, -1.36871851],
       [ 0.74606057,  0.66233779,  1.62115438],
       [ 0.19847858,  0.75267081,  0.131372  ],
       [ 0.90445575,  0.4101302 ,  0.53129698]])
>>> arr[arr<0] = 0
>>> arr
array([[0.27394406, 0.        , 0.        ],
       [0.66583687, 0.        , 0.        ],
       [0.        , 1.39024467, 0.        ],
       [0.74606057, 0.66233779, 1.62115438],
       [0.19847858, 0.75267081, 0.131372  ],
       [0.90445575, 0.4101302 , 0.53129698]])
```
## 4.1.6 神奇索引
为了选出一个符号特定顺序的子集，可以通过传递一个包含指明所需顺序的列表或数组来完成
```pyhon
>>> arr = np.empty((5, 3))
>>> arr
array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
>>> for i in range(5):
...    arr[i] = i
>>> arr
array([[0., 0., 0.],
       [1., 1., 1.],
       [2., 2., 2.],
       [3., 3., 3.],
       [4., 4., 4.]])
>>> arr[[0, 2]]
array([[0., 0., 0.],
       [2., 2., 2.]])
```

**注意，索引与切片不同，它总是将数据复制到一个新的数组中。**
### 重塑函数（未完）
在很多情况下，将数组从一个形状转换为另一个形状，并且不复制任何数据。reshape数组实例方法传递一个表示新形状的元组。
```python
>>> arr = np.zeros((3,4))
>>> for i in range(3):
...     arr[i] = i
>>> arr.reshape(1,12)
array([[0., 0., 0., 0., 1., 1., 1., 1., 2., 2., 2., 2.]])
```
**传递的形状维度可以有一个值是-1，表示维度通过数据进行推断**

数组的shape属性是一个元组，它也可以被传递给reshape
## 4.1.7 数组转置和换轴
转置是一种特殊的数据重组形式，可以返回底层数据的视图而不需要复制任何内容。数组拥有transpose方法，也有特殊T属性。

当进行矩阵计算时，可能会经常进行一些特定操作，比如，当计算矩阵内积会使用np.dot(x,y)

对于高维度的数组，transpose方法可以接收包含轴编号的元组，用于置换轴
```python
>>> x = np.ones((1, 2, 3))
>>> np.transpose(x, (1, 0, 2)).shape
(2, 1, 3)
```
参考博客：https://blog.csdn.net/u012762410/article/details/78912667

使用.T进行转置是换轴的一个特殊案例。ndarray有一个swapaxes方法，该方法接受一对轴编号作为参数，并对轴进行调整用于重组数据：
```python
>>> arr
 array([[[0,1,2,3],
         [4,5,6,7]],
        [[8,9,10,11],
         [12,13,14,15]]])
>>> arr.swapaxes(1,2)
array([[[0,4],
        [1,5],
        [2,6],
        [3,7]],
       [[8,12],
        [9,13],
        [10,14],
        [11,15]]])
```
**swapaxes返回的是数据的视图，而没有对数据进行复制。**  
# 4.2 通用函数：快速的逐元素数组函数
通用函数，也可以成为ufunc，是一种在ndarray数据中进行逐元素操作的函数。某些简单函数接收一个或多个标量数值，并产生一个或多个标量结果，而通用函数就是对这些简单函数的向量化封装。

**一元通用函数：**
| 函数名 | 描述 |
| :-----: | :----: |
| abs、fabs | 逐元素地计算整数、浮点数或复数的绝对值 |
| sqrt | 计算每个元素的平方根 |
| square | 计算每个元素的平方 |
| exp | 计算每个元素的自然指数值`$e^x$` |
| log、log10、log2、log1p | 分别对应：自然数对(e为底)、对数10为底、对数2为底、log(1+x) |
| sign | 计算每个元素的符号值：1、0、-1 |
| ceil | 计算每个元素的最高整数值（即大于等于给定元素的最大整数） |
| floor | 计算每个元素的最小整数值（...） |
| rint | 将元素保留到整数位，并保持dtype |
| modf | 分别将数组的小数部分和整数部分按数组形式返回 |
| isnan | 返回数组中的元素是否是一个NaN(不是一个数值)，形式为布尔值数组 |
| isfinite、isinf | 分别返回数组中的元素是否有限（非inf、非NaN）、是否无限，形式为布尔值数组 |
| cos、cosln、sin、sinh、tan、tanh | 常规的双曲三角函数 |
| arccos、arccosh、arcsin、arcsinh、arctan、arctanh | 反三角函数 |
| logical_not | 对数组的元素按位取反 |
**二元通用函数**
| 函数名 | 描述 |
| :-----: | :----: |
| add | 将数组的对应元素相加 |
| subtract | 在第二个数组中，将第一个数组中包含的元素去除 |
| multiply | 将数组的对应元素相乘 |
| divide, floor_divide | 除或整除 |
| power | 将第二个数组的元素作为第一个数组对应元素的幂次方 |
| maximum,fmax | 逐个元素计算最大值，fmax忽略NaN |
| minimum,fmin | ... |
| mod | 按元素的求模计算 |
| copysign | 将第一个数组的符号值改为第二个数组的符号值 |
| greater,greater_equal,less,less_qual,equal,not_equal | 进行逐个元素的比较，返回布尔值数组 |
| logical_and,logical_or,logical_xor | 进行逐个元素的逻辑运算 |
# 4.3 使用数组进行面向数组编程
使用NumPy数组可以使你利用简单的数组表达式完成多种数据操作任务，而无须写些大量循环。这种利用数组表达式来替代显示循环的方法，称为向量化。通常，向量化的数组操作会比纯Python的等价实现在速度上快一到两个数量级（甚至更多），这对所有种类的数值计算产生了最大的影响。


## 4.3.1 将条件逻辑作为数组操作
## 4.3.2 数学和统计方法
## 4.3.3 布尔值数组的方法
## 4.3.4 排序
## 4.3.5 唯一值与其他集合逻辑
# 4.4 使用数组进行文件输入和输出
# 4.5 线性代数
# 4.6 伪随机数生成
# 4.7 示例：随机漫步
## 4.7.1 一次性模拟多次随机漫步
# 4.8 本章小结
</font>
